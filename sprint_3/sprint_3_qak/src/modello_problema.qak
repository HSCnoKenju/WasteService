System -trace waste_service

// mqttBroker "broker.hivemq.com" : 1883 eventTopic "unibo/hu/waste"   //broker.hivemq.com

/* =================== MESSAGGI MODELLO ================== */

Request waste : details(TYPE,TRUCKLOAD) // TYPE: Glass / Plastic
Reply loadAccept : info(ok)  	// Reply loadAccepted : info(TYPE,WEIGHT,AVAILABLE_WEIGHT)   
Reply loadRejected : info(rip)   // Reply loadRejected : info(TYPE,WEIGHT,AVAILABLE_WEIGHT) 



/* =================== MESSAGGI PROBLEMA =============== */ 


Request goal : destination(CONTAINER) // Glass / Plastic
Event pickup : info(TYPE) // Glass / Plastic
Reply workdone : info(done)

/* =================== MESSAGGI CONFIGURAZIONE ==================== */

Dispatch init_capacity : values(MAXGB,MAXPB)
Dispatch all_position : coordinates(HOMEX,HOMEY,INDOORX,INDOORY,PLASTICX,PLASTICY,GLASSX,GLASSY)
Dispatch start_position : coordinates(STARTX,STARTY)


/*=================== TEST PURPOSE =============================== */

Dispatch reset : info(ARGS)

/*=======================	PLANNER =================================== */

Request destination : dest(DESTX, DESTY)
Reply arrived : info(done)

Request  dopath   : dopath( PATH  )
Reply dopathdone  : dopathdone( ARG ) 
Reply dopathfail  : dopathfail( ARG )

Dispatch setMap   : setMap (MapStr ) 

/* ===================   MAPPER     ================================= */

Request buildMap : build(FILEPATH)
Reply mapCreated : info (FILEPATH)

Dispatch cmd       : cmd(MOVE)  
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
//Event alarm        : alarm(X)


/*==================	ROBOT		================================ */

Dispatch cmd       	: cmd(MOVE)     
Dispatch end       	: end(ARG)  
  
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
   
Dispatch obstacle  : obstacle( ARG ) 	//generated by distancefilter
Event   info       : info( ARG ) 	    //for external components, not coap-observed

Event alarm        : alarm(X) 


/* ========================= SPRINT 2 =============================  */  
Event sonardata : distance(DISTANCE) 
Event stop : stop(ARGS)
Event resume : resume(ARGS)
 

Dispatch ledtrigger : led(CMD)
Event robotState : info(ATHOME,MOVING,STOPPED,TIMESTAMP) 


Dispatch coapUpdate: coapUpdate(RESOURCE, VALUE)



/* ====================== LED =============================== */


Event weight : info(PLASTIC,GLASS)
Event position : info(POSITION)
Event ledstate : info(LEDSTATE)
Event servicestate : info(SERVICESTATE)


Context ctxbasicrobot  ip [host="localhost" port=8020]
Context ctxpathexec  ip [host="localhost" port=8043]  
Context ctxpathplanner   ip [host="localhost" port=8078]
Context ctxconfig ip [host="localhost" port=8034]
Context ctxtest ip [host="localhost" port=8035]
Context ctxwaste ip [ host="localhost" port=8033]
Context ctxledqak22 ip [host="localhost" port=8065]
Context ctxgui ip [host="localhost" port=8082]
Context ctxtruck ip[host="localhsot" port=8083]
Context ctxsonarqak22 ip [host="localhost" port=8061]  


QActor gui context  ctxgui { 
	
	State s0 initial{
		
		observeResource  waste_service
		observeResource  transporttrolley
		observeResource  trolleyanalyzer
		observeResource  led
	}
	Transition t0  whenMsg coapUpdate -> handle
	
	State handle {}
}

QActor trolleyanalyzer context ctxwaste {
	
	State s0 initial {
		println("		TROLLEY_ANALYZER | STARTED")	
	}
	Transition t0 whenEvent robotState ->  handle
	
	State handle {
		
		forward led -m ledtrigger : led("blink")
	}
} 

QActor thresholdchecker context ctxwaste {
	
	State s0 initial {
		
		observeResource  sonar
	}
	Transition t0 whenMsg coapUpdate -> handle
	
	
	State handle {
		
		emit stop : stop("stop")
		emit resume : resume ("resume")
		
	}
}


QActor sonar context ctxsonarqak22 {
	
	State s0 initial{
		
		
	}
	
	State send {
		
		// emit sonardata : distance(10) 
		
	}

}

QActor led context ctxledqak22{
	State s0 initial{
		
	
	}
	Transition t0 whenMsg ledtrigger -> handle
	
	
	State handle {
		
	}
	
	
}


QActor pathexec context ctxpathexec{ 
[# var CurMoveTodo = ""    //Upcase, since var to be used in guards
   var StepTime    = "300"
#]
	State s0 initial{  	
		//printCurrentMessage
		[#  CurMoveTodo = "" 
			StepTime = unibo.robot.robotSupport.readStepTime()
		#]
		println("pathexec ready. StepTime=$StepTime") 
	}	
	Transition t0 whenRequest dopath -> doThePath
  	
	State doThePath{
		printCurrentMessage 
		//[# prinln( currentMsg ) #]
		onMsg ( dopath : dopath( PATH )){
			run pathut.setPath( payloadArg(0) )  //se payloadArg fallisce non da eccezione! (ma non fa nulla)
		}		 
		println("pathexec pathTodo = ${pathut.getPathTodo()}") 
 	}
	Goto nextMove    
	
	
	State nextMove{ 
		[# CurMoveTodo = pathut.nextMove() #]	
		//println("pathexec curMoveTodo=$CurMoveTodo" )
	} 
	Goto endWorkOk if [# CurMoveTodo.length == 0 #] else doMove
	
	State doMove{
		//printCurrentMessage
 		delay 345  //avoid too fast ...
 	}
	Goto doMoveW if [# CurMoveTodo == "w" #] else doMoveTurn
	
	State doMoveTurn{
		//printCurrentMessage
		forward basicrobot -m cmd : cmd($CurMoveTodo) //asynch !!!		
	}
	Transition t0 whenTime 345  ->  nextMove  //wait for move done ...
  
 	State doMoveW{
		//printCurrentMessage
		emit robotState : info("false","true","false",1234567890)
		request basicrobot -m step : step( $StepTime )
	}	
	Transition t0 whenEvent alarm     -> endWorkKo
 				  whenReply stepdone  -> nextMove  
	              whenReply stepfail  -> endWorkKo
	              whenEvent stop ->   stopState                     
	              
	State endWorkOk{
		//printCurrentMessage
		println("endWorkOk: PATH DONE - BYE")
		replyTo dopath with dopathdone : dopathdone( ok )
	}
	Goto s0 

	State endWorkKo{
		printCurrentMessage
		[# var PathStillTodo = pathut.getPathTodo() #]
		println("PATH FAILURE - SORRY. PathStillTodo=$PathStillTodo")
		replyTo dopath with dopathfail : dopathfail( $PathStillTodo )
	}	
	Goto s0


	State stopState {
		
	}
	Transition to whenEvent resume -> doMoveW

} 
 


 
QActor basicrobot context ctxbasicrobot{
[#
  var StepTime      = 0L
  var StartTime     = 0L     
  var Duration      = 0L  
  var RobotType     = "" 
  var CurrentMove   = "unkknown"
#]  
 	State s0 initial { 	      
 		discardMsg Off  //WE want receive any msg
		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
 		delay 1000  //give to the realsonar the time to start
        if[# RobotType != "virtual" #]{
        	[# var robotsonar = context!!.hasActor("realsonar")  
        	   if(robotsonar != null) unibo.robot.robotSupport.createSonarPipe(robotsonar) 
        	#] 
  		}//The Virtual robot sonardata is created in virtualrobotSupport2021
 
  		run unibo.robot.robotSupport.move( "l" )    //synch
 		run unibo.robot.robotSupport.move( "r" )	//synch
    		//run unibo.robot.robotSupport.move( "w" )    //asynch
 		updateResource [# "basicrobot(start)" #]
 	} 
	Goto work
	
	State work{ 
		println("basicrobot  | waiting .................. ")  
	} 
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep			
					whenMsg    obstacle   -> handleObstacle  //in virtualrobot caused by the move w/s
					//whenEvent sonardata       -> handleSonar
				  	whenMsg     end       -> endwork			  
	
	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors  
			run unibo.robot.robotSupport.move( payloadArg(0 ) )
			updateResource [# "moveactivated(${payloadArg(0)})" #]
		}
	 }
	 Goto work  
	 
	State handleObstacle{
		//println("basicrobot | handleObstacle")	
		run unibo.robot.robotSupport.move( "h" )
		//printCurrentMessage
		updateResource [# "obstacle(${CurrentMove})" #]
		if[# CurrentMove == "w"#]{
		//back to avoid emission of obstacle again if real robot moving forward !!!
		//if[# RobotType != "virtual" #]{	//is it better to embed this behavior in the support?
			run unibo.robot.robotSupport.move( "s" )
			delay 100 
			run unibo.robot.robotSupport.move( "h" ) 
 		}
 		emit info : info( obstacledoing(w) )
	}
	Goto work 
 
	State handleSonar{
		printCurrentMessage
	}
	Goto work
		
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doStep StepTime =$StepTime  ")        
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever !!!
	}  
	Transition t0 
		whenTimeVar StepTime  -> stepDone  	 
 		whenMsg  obstacle     -> stepFail		
    	 
	
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done ???
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		println("basicrobot | stepDone reply done")
  	}
	Goto work  
 
	State stepFail{  		
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		[# var TunedDuration = Duration;  
			TunedDuration = Duration * 5 / 6
		#]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration 
			run unibo.robot.robotSupport.move( "h" ) 
 		updateResource [# "stepFail($Duration)" #] 
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work
	
	State endwork{ 
		updateResource [# "basicrobot(end)" #]	 		
 		terminate 1
	}   
 
}




QActor pathplanner context ctxpathplanner{
	[# val Inmapname   = "xxx" //"map2019"  
	   var PathTodo    =  ""  
	   var CurGoalX    = 3
	   var CurGoalY    = 3 
	   var mapExist 	= true
	   var Outmapname = "yyy"
	#]
	State activate initial {  
		
		
		
		[# mapExist = filechecker.fileExists(Inmapname)#]
		
		if [#( mapExist 	) #]{
			
		}
		else {
			
			request boundarymapbuilder -m buildMap : build($Inmapname)
			
			
		}
 	
	}
	Goto  readMap if [# mapExist#] else  dummy_wait_build
				  
	
	State dummy_wait_build {
		
	}
	
	Transition t0 whenReply mapCreated -> readMap
	
	State readMap{
			//run unibo.kotlin.planner22Util.loadRoomMap( Inmapname )	
 		run unibo.kotlin.planner22Util.createRoomMapFromTextfile( "$Inmapname.txt" )	  
   		run unibo.kotlin.planner22Util.initAI() 
  		run unibo.kotlin.planner22Util.showCurrentRobotState()
// 		forward pathexec -m setMap :  map( $MapStr )  //no more
	}
	Goto accepting
	   
	   
	State accepting {
		println(" PATH PLANNER | ACCEPTING")
	}
	Transition t0 whenRequest destination -> findAPath
	
	
	State findAPath{
		
		println("PATH PLANNER | FIND A PATH")
		
		
		onMsg ( destination : dest(DESTX, DESTY) ) { // se mi arriva un destination, Ã¨ una nuova richiesta e copio i Goal
			
			printCurrentMessage
			[#
			
				CurGoalX = payloadArg(0).toInt()
				CurGoalY = payloadArg(1).toInt()
				
			#]
		}
		else {
			
			println("Keep searching $CurGoalX, $CurGoalY")
		}
		
		
		qrun userContinue.userEnd(myself)
		
		// se non passa, sono qui da pathko, ho aggiornato la mappa con l'ostacolo e posso richiedere alla "mente" un nuovo percorso
		
		run unibo.kotlin.planner22Util.setGoal(CurGoalX,CurGoalY)  //---x--->
		[# PathTodo = unibo.kotlin.planner22Util.doPlan().toString()  //List<aima.core.agent.Action>  [w, w, l, w] 
			.replace(" ","")
			.replace(",","")
			.replace("[","")
			.replace("]","")
		#]  
		println("Azioni pianificate: $PathTodo")
 		if [# PathTodo.length == 0 #] {
 			println("WARNING: nessuna azione pianificata. Il piano vuoto viene comunque eseguito")
 		}
 		request pathexec -m dopath : dopath( $PathTodo )  
		
	} 
	Transition t0 whenReply dopathdone -> pathok 
				  whenReply dopathfail -> pathko
  	
	State pathok{ 
		printCurrentMessage
		//Aggiorno la mappa con PathToDo
		run  unibo.kotlin.planner22Util.updateMapWithPath( PathTodo )
		run  unibo.kotlin.planner22Util.showCurrentRobotState()
		run unibo.kotlin.planner22Util.saveRoomMap("$Outmapname")
		
		replyTo destination with arrived : info(done)
	}
	
	Goto accepting
	
	
    State pathko{
		printCurrentMessage
		onMsg ( dopathfail : dopathfail( P ) ){
			[#  val planStillTodo = payloadArg(0) 
				var p =""
				if( planStillTodo=="none"){ //l'ultimo w ha provocato il fail
					p = PathTodo.dropLast(1)
				}else{
					p = PathTodo.dropLast( planStillTodo.length+1 ) //un w ha provocato il fail
				}
				println("planStillTodo:$planStillTodo over $PathTodo done: $p")
			#]
			run unibo.kotlin.planner22Util.updateMapWithPath( p )
			run unibo.kotlin.planner22Util.updateMapObstacleOnCurrentDirection()
		}
		//run unibo.kotlin.planner22Util.showMap()
		run unibo.kotlin.planner22Util.showCurrentRobotState()
		run unibo.kotlin.planner22Util.saveRoomMap("$Outmapname")
 		//emit alarm : alarm(obstacle) 		
 	}
 	Goto findAPath
//
//    State end{
//    	println("BYE")
//    }
}


/*  
 * ------------------------------------------------------------------
 *  cleanerwalker 
 * ------------------------------------------------------------------
*/     

QActor boundarymapbuilder context ctxpathplanner{    
	[# var NumStep   = 0 
		val StepLength = 350L
		val DelayLength = 300L
		
		
		var MapFilePath = ""
		#
	]
	State s0 initial{  	
		println("		MAPPER | START") 
		[# unibo.kotlin.planner22Util.initAI() #]
	}		
	Goto accepting
	
	
	
	State accepting {
		
		println("		MAPPER | ACCEPTING")
		
	}
	Transition t0 whenRequest buildMap -> processRequest
	
	State processRequest{
		
		onMsg ( buildMap : build(FILEPATH)){
			
			[#
			
			MapFilePath = payloadArg(0)
					
			#]
			
			
		}
	} Goto doAheadMove
	
	State doAheadMove {
		delayVar DelayLength
		request basicrobot -m step : step($StepLength)
	}
	Transition t0 whenReply stepdone -> continue
	              whenReply stepfail -> turn
	
	State continue{
		[# unibo.kotlin.planner22Util.updateMap(  "w", "" ) #]
	}  
	Goto doAheadMove
	            
	State turn {
		[# NumStep = NumStep + 1 #]
		forward basicrobot -m cmd : cmd(l)
		[#  unibo.kotlin.planner22Util.updateMap(  "l", "" ) 
			unibo.kotlin.planner22Util.showMap()		 
		#]
	}
    Goto doAheadMove if [# NumStep < 4 #]  else endwork
    
    State endwork{ 
 		[# 	unibo.kotlin.planner22Util.showMap();
 			unibo.kotlin.planner22Util.saveRoomMap("$MapFilePath");
		#]
		replyTo buildMap with mapCreated : info (MapFilePath)
		println("		MAPPER | START") 
 		terminate 1
	}  
	              
}







QActor configurer context ctxconfig {
	
	State s0 initial {
		
	}
	
	State send {
		
		forward waste_service -m init_capacity : values(30,30)
		forward transporttrolley -m start_position  : coordinates(0,0)
		forward transporttrolley -m all_position : coordinates(0,0,1,5,6,2,1,6)
	}
}

QActor tester context ctxtest {
	
	State s0 initial {
		
	}
	
	State send {
		
		forward waste_service -m reset : info("reset")
	}
}



QActor transporttrolley context ctxwaste {
	
	
	
	
	
	[#
		resourceappender.initResource()
		var CurrentType = ""
		var PositionsMap: Map<String, Pair<Int,Int>> = emptyMap()
		//var CurrentPosition: Pair<Int,Int>
	#]
	
	State s0 initial {
		println("		TRANSPORT TROLLEY | STARTED")	
	}
	//Goto accepting
	Transition t1 whenMsg all_position ->  gotPositions
	
	
	
	State gotPositions {
		
		printCurrentMessage
		
		onMsg (  all_position : coordinates(HOMEX,HOMEY,INDOORX,INDOORY,PLASTICX,PLASTICY,GLASSX,GLASSY) ) { 
			
			[#
				PositionsMap = mapOf ("HOME" to Pair(payloadArg(0).toInt(),payloadArg(1).toInt()), "INDOOR" to Pair(payloadArg(2).toInt(),payloadArg(3).toInt()), "PLASTIC" to Pair(payloadArg(4).toInt(),payloadArg(5).toInt()), "GLASS" to Pair(payloadArg(6).toInt(),payloadArg(7).toInt())  )
				
			#]
		}
		// limiti di qak, forse sfruttando prolog posso pensare di fare una 'lista' di posizioni
	
	
	[#	println("mappa ${PositionsMap.toString()}") #]
	}
	/*Transition t1 whenMsg start_position -> setStart
	
	State setStart {
		
		
		printCurrentMessage
		
		onMsg (start_position : coordinates(STARTX,STARTY)) {
			
			[#
				CurrentPosition = Pair(payloadArg(0).toInt(),payloadArg(1).toInt())
					
			#]
		}
		
	}*/
	Goto accepting
	
	State accepting {
		
		[# resourceappender.initResource()	#]
		
		printCurrentMessage
		println("		TRANSPORT TROLLEY | NEW WORK")	
	}
	Transition t0 whenRequest goal -> goingIndoor
	
	
	State goingIndoor {
		
		[#resourceappender.add("ACCEPTED")#]	
		updateResource[#resourceappender.getStr()#]
		
		onMsg ( goal : destination(CONTAINER) ){
			[#
			
			CurrentType = payloadArg(0)
				
			#]
			
			}
		
		[#
		var DestX =  PositionsMap["INDOOR"]?.first
		var DestY = PositionsMap["INDOOR"]?.second
		#
		]
		
		request pathplanner -m destination :  dest($DestX,$DestY)
	}
	Transition t1 whenReply arrived -> arriveIndoor
	
	State arriveIndoor {
	
		
			[#resourceappender.add("INDOOR")#]		
		updateResource[#resourceappender.getStr()#]
			
			
		
		
		emit pickup : info($CurrentType)
		println("		TRANSPORT TROLLEY | INDOOR")	
		
		// going Container
		
		[#
		var DestX =  PositionsMap[CurrentType.uppercase()]?.first
		var DestY = PositionsMap[CurrentType.uppercase()]?.second
		#
		]
		
		request pathplanner -m destination :  dest($DestX,$DestY)
		
	
	
	}
	Transition t1 whenReply arrived -> arriveContainer
	
	
	State arriveContainer {
		[#resourceappender.add("$CurrentType")#]
		updateResource[#resourceappender.getStr()#]
		
		replyTo goal with workdone : info(done)
	 	println("		TRANSPORT TROLLEY | $CurrentType")	
	
	}
	Transition t1  whenTime 500 -> goingHome 
				   whenRequest goal -> goingIndoor /*else Goto accepting*/
				   
	 			   
	
	State goingHome {
		
		[#
		var DestX =  PositionsMap["HOME"]?.first
		var DestY = PositionsMap["HOME"]?.second
		#
		]
		
		request pathplanner -m destination :  dest($DestX,$DestY)
		
		
		
	
	}
	Transition t1 whenReply arrived -> arriveHome
	
	
	State arriveHome{
		[#resourceappender.add("HOME")#]
		updateResource[#resourceappender.getStr()#]
		
		emit robotState : info("true","false","false",0123456789)
		
		println("		TRANSPORT TROLLEY | going HOME")	
		
	}
	Goto accepting
	
}


QActor waste_truck_mock context ctxtruck {
	
	State s0 initial {
		println("		WASTE_TRUCK GENERATOR | STARTED")
	}
	/*Goto newLoad*/
	
	State newLoad{
			println("		WASTE_TRUCK GENERATOR | NEW REQUEST")
			request waste_service -m waste : details(Glass,2)
			//request waste_service -m waste : details(Plastic,11)
	}
	Transition t0 whenReply loadAccept -> accepted
				  whenReply loadRejected -> rejected
	
	State accepted{
		
		printCurrentMessage
	}
	Goto end
	
	State rejected{
		
		printCurrentMessage
	}
	Goto end
	
	State end {
		println("		WASTE_TRUCK GENERATOR | END")
	}
	
}





QActor waste_service context ctxwaste {
	[#
		var Available_Glass = 0
		var Available_Plastic = 0
		var RequestedType  = ""
		var RequestedWeight = 0
		var Available = true 
		
		var Init_Glass = 0
		var Init_Plastic = 0
	#]
	
	State s0 initial {
			println("WASTE_SERVICE | STARTED")
	}
	Transition t1 whenMsg init_capacity  -> getWeights
	/*Goto accepting*/
	
	
	
	State getWeights{
		
		printCurrentMessage
		onMsg ( init_capacity : values(MAXGB,MAXPB)) {
			
			[#
			
				Available_Glass = payloadArg(0).toInt()
				Available_Plastic = payloadArg(1).toInt()
				Init_Glass = payloadArg(0).toInt()
				Init_Plastic = payloadArg(1).toInt()
				
				
			#]
		}
	}
	Goto accepting
	
	
	State accepting {
			println("WASTE_SERVICE | ACCEPTING")
		}
	Transition t0 whenRequest waste -> check_availability
				  whenMsg 	reset -> reset_weights
				  
	
	
	State reset_weights {
		
		println("WASTE_SERVICE | SHOULD ONLY BE IN TESTING, RESET WEIGHTS")
	
	
		[#
		
		Available_Glass = Init_Glass
		Available_Plastic = Init_Plastic
		
			
		#]
		updateResource[#"Glass=$Available_Glass Plastic=$Available_Plastic "#]
	}
	Goto accepting
	
	State check_availability {
		printCurrentMessage
		println("WASTE_SERVICE | CHECK AVAILABILITY")	
		onMsg ( waste : details(TYPE,TRUCKLOAD) ) {
			[#
				RequestedType = payloadArg(0)
				RequestedWeight = payloadArg(1).toInt()

					if (RequestedType == "Glass"){
						Available = RequestedWeight <= Available_Glass
					}
					else if (RequestedType == "Plastic"){
						Available = RequestedWeight <= Available_Plastic
					}
				else 
					{	
						println("WASTE_SERVICE | WRONG TYPE")
						Available = false
					}
			#]
			
			if [# (Available)#] {
			//replyTo waste with  loadAccept : info(ok)
			} else {
			updateResource [# "Glass=$Available_Glass Plastic=$Available_Plastic"#]
			replyTo waste with  loadRejected : info(rip)
			}			
		}
	}
	Goto  issue_trolley if [#Available# ] else accepting
	
	State issue_trolley {
		
		println("WASTE_SERVICE | ISSUE TROLLEY")
		request transporttrolley -m goal : destination($RequestedType)
		
	}
	Transition t1 whenReply workdone -> lost_pickup 
				  whenEvent pickup -> updateWeights	
	
	State lost_pickup{
	
		[#
			
			if (RequestedType == "Glass"){
						Available_Glass -= RequestedWeight 
					}
			else if (RequestedType == "Plastic"){
						Available_Plastic -= RequestedWeight 
					}
			else 
					{	
						println("WASTE_SERVICE | ERROR LOST PICKUP")
					}
	
		#]
		updateResource [# "Glass=$Available_Glass Plastic=$Available_Plastic"#]
		replyTo waste with loadAccept : 	info(ok)
		
	}
	Goto accepting
	
	
	State updateWeights{
			[#
			
			if (RequestedType == "Glass"){
						Available_Glass -= RequestedWeight 
					}
			else if (RequestedType == "Plastic"){
						Available_Plastic -= RequestedWeight 
					}
			else 
					{	
						println("WASTE_SERVICE | ERROR UPDATE WEIGHTS")

					}
	
			#]
			
		updateResource [# "Glass=$Available_Glass Plastic=$Available_Plastic"#]
		replyTo waste with loadAccept : info(ok)
	}
	Goto acceptBusy
	
	
	State acceptBusy{
		
		println("WASTE_SERVICE | ACCEPTING(BUSY)")
	}
	Transition t2 whenReply workdone -> accepting
				  whenRequest waste -> checkWhenBusy
				  whenMsg reset -> reset_weightsBusy
	
	
	State reset_weightsBusy {
		
		println("WASTE_SERVICE | (BUSY) SHOULD ONLY BE IN TESTING, RESET WEIGHTS")
	
	
		[#
		
		Available_Glass = Init_Glass
		Available_Plastic = Init_Plastic
		
			
		#]
		updateResource[# "Glass=$Available_Glass Plastic=$Available_Plastic"#]
	}
	Goto acceptBusy
	
	
	
	State checkWhenBusy{
		printCurrentMessage
		println("WASTE_SERVICE | CHECK AVAILABILITY")	
		onMsg ( waste : details(TYPE,TRUCKLOAD) ) {
			[#
				RequestedType = payloadArg(0)
				RequestedWeight = payloadArg(1).toInt()

					if (RequestedType == "Glass"){
						Available = RequestedWeight <= Available_Glass
					}
					else if (RequestedType == "Plastic"){
						Available = RequestedWeight <= Available_Plastic
					}
				else 
					{	
						println("WASTE_SERVICE | WRONG TYPE")
						Available = false
					}
			#]
			
			if [# (Available)#] {
			//replyTo waste with  loadAccept : info(ok)
			} else {
			updateResource [# "Glass=$Available_Glass Plastic=$Available_Plastic"#]
			replyTo waste with  loadRejected : info(rip)
			}			
		}
	}
	Goto addRequestToQueue if [# Available#] else acceptBusy
	
	State addRequestToQueue{
		
		println("WASTE_SERVICE | ISSUE TROLLEY TO QUEUE")
		request transporttrolley -m goal : destination($RequestedType)
		
	}
	Goto acceptBusy
}