System /*-trace*/ waste_service

// mqttBroker "broker.hivemq.com" : 1883 eventTopic "unibo/hu/waste"   //broker.hivemq.com

/* =================== MESSAGGI MODELLO ================== */

Request waste : details(TYPE,TRUCKLOAD) // TYPE: Glass / Plastic
Reply loadAccept : info(ok)  	// Reply loadAccepted : info(TYPE,WEIGHT,AVAILABLE_WEIGHT)   
Reply loadRejected : info(rip)   // Reply loadRejected : info(TYPE,WEIGHT,AVAILABLE_WEIGHT) 



/* =================== MESSAGGI PROBLEMA =============== */ 


Request goal : destination(CONTAINER) // Glass / Plastic
Event pickup : info(TYPE) // Glass / Plastic
Reply workdone : info(done)





/* =================== MESSAGGI CONFIGURAZIONE ==================== */

Dispatch init_capacity : values(MAXGB,MAXPB)
Dispatch all_position : coordinates(HOMEX,HOMEY,INDOORX,INDOORY,PLASTICX,PLASTICY,GLASSX,GLASSY)
Dispatch start_position : coordinates(STARTX,STARTY)


/*=================== TEST PURPOSE =============================== */

Dispatch reset : info(ARGS)

/*=======================	PLANNER =================================== */

Request destination : dest(DESTX, DESTY)
Reply arrived : info(done)


/*===========================	Sprint_2 : RPI	============================ */
Event sonardata : sonardata(DISTANCE) 
Event ledtrigger : led(CMD) // on - off - blink

Event stop : stop(ARGS)
Event resume : resume(ARGS)


// se facessi due eventi distinti, uno per stop uno per resume ?

Event robotState : info(ATHOME,MOVING,STOPPED,TIMESTAMP)




Context ctxpathexec ip [host="127.0.0.1" port=8049]
Context ctxpathplanner   ip [host="127.0.0.1" port=8078]
Context ctxledqak22 ip [host="127.0.0.1" port=8065] 
Context ctxwaste ip [ host="localhost" port=8033]

ExternalQActor pathplanner context ctxpathplanner



QActor trolleyanalyzer context ctxwaste {
	[# 
		var LastStatusTimestamp = timestamputil.TimestampMin() 
		var stopped = true
		var continuos = false
	#]
	

	
	

	State s0 initial {
		// println("		TROLLEY_ANALYZER | STARTED")	
	}
	Goto accept
	
	State accept {
		// println("		TROLLEY_ANALYZER | ACCPEPTING")	
	}
	Transition t0 whenEvent robotState ->  check_stopped
	
	State check_stopped {
		//println("		TROLLEY_ANALYZER | CHECK_STOPPED")	
		//printCurrentMessage
		onMsg ( robotState : info(ATHOME,MOVING,STOPPED,TIMESTAMP)) {
			[#
				var CurrentTimestamp = payloadArg(3)
			 	var Ahomeinput = payloadArg(0).toBoolean()
			 	var Movinginput = payloadArg(1).toBoolean()
			 	var Stoppedinput = payloadArg(2).toBoolean()
			 	#]
			 	println("CurrentTimestamp=$CurrentTimestamp Ahomeinput=$Ahomeinput Movinginput=$Movinginput  Stoppedinput=$Stoppedinput ")
			 	[#
			 	if (Ahomeinput && !Movinginput  && !Stoppedinput ){
			 		stopped = false
			 		continuos = true
#]
					
					updateResource [#"trolleyState(idle)"#]
					emit ledtrigger : led(off) // on - off - blink
[#			 		
			 	} else if (!Ahomeinput && Movinginput && !Stoppedinput ){
			 		stopped = false 
			 		continuos = false
#]
					updateResource [#"trolleyState(working)"#]
					emit ledtrigger : led(blink) // on - off - blink
[#
			 	} else if (!Ahomeinput && !Movinginput && Stoppedinput ) {
			 		stopped = true 
			 		continuos = false
#]
					updateResource [#"trolleyState(stopped)"#]
					emit ledtrigger : led(on) // on - off - blink
[#
			 	}
			 	else {
			 		// msg format error
			 		#]
			 		println("TROLLEY_ANALYZER	|	MSG FORMAT ERROE")
			 		[#
			 	}
			 	LastStatusTimestamp =  CurrentTimestamp
			
			
			
			#]
		}
	}
	Transition t0 whenEvent robotState ->  check_stopped
	}


QActor thresholdchecker context ctxwaste {
	
	
	[#
	
	val DLIMIT = 40
	
	var HigherThanLimit = false
		
	#]
	
	State s0 initial {
		//println("		THRESHOLD_CHECKER | STARTED")	
	}
	Goto accept
	
	
	State accept {
		
		//println(" THRESHOLD_CHECKER | ACCEPTING")
	}
	Transition t0 whenEvent sonardata -> check
	
	
	State check{
		
		//printCurrentMessage
		
		onMsg(sonardata : distance(DISTANCE)){
			
			
			[#
			
				var Distance = payloadArg(0).toInt()
				
				HigherThanLimit = (Distance >= DLIMIT) 
			
				
			#]
		}
	}
	
	Goto broadcastResume if [# HigherThanLimit #] else  broadcastStop
	
	
	
//	Event stop : stop(ARGS)
//Event resume : resume(ARGS)

	State broadcastStop{
		
		emit stop : stop(stop)
	}
	Goto accept
	
	State broadcastResume{
		emit resume : resume(resume)
	}
	Goto accept
}



QActor transporttrolley context ctxwaste { // trolley_facade
	
	
	
	
	
	[#
		resourceappender.initResource()
		var CurrentType = ""
		var PositionsMap: Map<String, Pair<Int,Int>> = emptyMap()
		//var CurrentPosition: Pair<Int,Int>
	#]
	
	State s0 initial {
		println("		TRANSPORT TROLLEY | STARTED")	
	}
	//Goto accepting
	Transition t1 whenMsg all_position ->  gotPositions
	
	
	
	State gotPositions {
		
		printCurrentMessage
		
		onMsg (  all_position : coordinates(HOMEX,HOMEY,INDOORX,INDOORY,PLASTICX,PLASTICY,GLASSX,GLASSY) ) { 
			
			[#
				PositionsMap = mapOf ("HOME" to Pair(payloadArg(0).toInt(),payloadArg(1).toInt()), "INDOOR" to Pair(payloadArg(2).toInt(),payloadArg(3).toInt()), "PLASTIC" to Pair(payloadArg(4).toInt(),payloadArg(5).toInt()), "GLASS" to Pair(payloadArg(6).toInt(),payloadArg(7).toInt())  )
				
			#]
		}
		// limiti di qak, forse sfruttando prolog posso pensare di fare una 'lista' di posizioni
	
	
	[#	println("mappa ${PositionsMap.toString()}") #]
	}
	/*Transition t1 whenMsg start_position -> setStart
	
	State setStart {
		
		
		printCurrentMessage
		
		onMsg (start_position : coordinates(STARTX,STARTY)) {
			
			[#
				CurrentPosition = Pair(payloadArg(0).toInt(),payloadArg(1).toInt())
					
			#]
		}
		
	}*/
	Goto accepting
	
	State accepting {
		
		[# resourceappender.initResource()
			
			resourceappender.add("position(")
			
			#
		]
		
		printCurrentMessage
		println("		TRANSPORT TROLLEY | NEW WORK")	
	}
	Transition t0 whenRequest goal -> goingIndoor
	
	
	State goingIndoor {
		
		[#resourceappender.add("ACCEPTED")#]	
		updateResource[#resourceappender.getStr()+")"#]
		
		onMsg ( goal : destination(CONTAINER) ){
			[#
			
			CurrentType = payloadArg(0)
				
			#]
			
			}
		
		[#
		var DestX =  PositionsMap["INDOOR"]?.first
		var DestY = PositionsMap["INDOOR"]?.second
		#
		]
		
		request pathplanner -m destination :  dest($DestX,$DestY)
	}
	Transition t1 whenReply arrived -> arriveIndoor
	
	State arriveIndoor {
	
		
			[#resourceappender.add("INDOOR")#]		
		updateResource[#resourceappender.getStr()+")"#]
			
			
		
		
		emit pickup : info($CurrentType)
		println("		TRANSPORT TROLLEY | INDOOR")	
		
		// going Container
		
		[#
		var DestX =  PositionsMap[CurrentType.uppercase()]?.first
		var DestY = PositionsMap[CurrentType.uppercase()]?.second
		#
		]
		
		request pathplanner -m destination :  dest($DestX,$DestY)
		
	
	
	}
	Transition t1 whenReply arrived -> arriveContainer
	
	
	State arriveContainer {
		[#resourceappender.add("$CurrentType")#]
		updateResource[#resourceappender.getStr()+")"#]
		
		replyTo goal with workdone : info(done)
	 	println("		TRANSPORT TROLLEY | $CurrentType")	
	
	}
	Transition t1  whenTime 500 -> goingHome 
				   whenRequest goal -> goingIndoor /*else Goto accepting*/
				   
	 			   
	
	State goingHome {
		
		[#
		var DestX =  PositionsMap["HOME"]?.first
		var DestY = PositionsMap["HOME"]?.second
		#
		]
		
		request pathplanner -m destination :  dest($DestX,$DestY)
		
		
		
	
	}
	Transition t1 whenReply arrived -> arriveHome
	
	
	State arriveHome{
		[#resourceappender.add("HOME")#]
		updateResource[#resourceappender.getStr()+")"#]
		
		[#
		
			var CurTimestamp = 	 timestamputil.TimestampNow()
		#
		]
		
		emit robotState : info(true,false,false,$CurTimestamp)
		
		println("		TRANSPORT TROLLEY | going HOME")	
		
	}
	Goto accepting
	
}

/* 
QActor waste_truck_mock context ctxwaste {
	
	State s0 initial {
		println("		WASTE_TRUCK GENERATOR | STARTED")
	}
	//Goto newLoad
	
	State newLoad{
			println("		WASTE_TRUCK GENERATOR | NEW REQUEST")
			request waste_service -m waste : details(Glass,2)
			//request waste_service -m waste : details(Plastic,11)
	}
	Transition t0 whenReply loadAccept -> accepted
				  whenReply loadRejected -> rejected
	
	State accepted{
		
		printCurrentMessage
	}
	Goto end
	
	State rejected{
		
		printCurrentMessage
	}
	Goto end
	
	State end {
		println("		WASTE_TRUCK GENERATOR | END")
	}
	
}

*/




QActor waste_service context ctxwaste {
	[#
		var Available_Glass = 0
		var Available_Plastic = 0
		var RequestedType  = ""
		var RequestedWeight = 0
		var Available = true 
		
		var Init_Glass = 0
		var Init_Plastic = 0
	#]
	
	State s0 initial {
			println("WASTE_SERVICE | STARTED")
	}
	Transition t1 whenMsg init_capacity  -> getWeights
	/*Goto accepting*/
	
	
	
	State getWeights{
		
		printCurrentMessage
		onMsg ( init_capacity : values(MAXGB,MAXPB)) {
			
			[#
			
				Available_Glass = payloadArg(0).toInt()
				Available_Plastic = payloadArg(1).toInt()
				Init_Glass = payloadArg(0).toInt()
				Init_Plastic = payloadArg(1).toInt()
				
				
			#]
		}
	}
	Goto accepting
	
	
	State accepting {
			println("WASTE_SERVICE | ACCEPTING")
		}
	Transition t0 whenRequest waste -> check_availability
				  whenMsg 	reset -> reset_weights
				  whenReply workdone -> lost_pickup 
				  whenEvent pickup -> updateWeights		
				  
	
	
	State reset_weights {
		
		println("WASTE_SERVICE | SHOULD ONLY BE IN TESTING, RESET WEIGHTS")
	
	
		[#
		
		Available_Glass = Init_Glass
		Available_Plastic = Init_Plastic
		
			
		#]


		updateResource[#"weights(Glass=$Available_Glass Plastic=$Available_Plastic)"#]
	}
	Goto accepting
	
	State check_availability {
		printCurrentMessage
		println("WASTE_SERVICE | CHECK AVAILABILITY")	
		onMsg ( waste : details(TYPE,TRUCKLOAD) ) {
			[#
				RequestedType = payloadArg(0)
				RequestedWeight = payloadArg(1).toInt()

					if (RequestedType == "Glass"){
						Available = RequestedWeight <= Available_Glass
					}
					else if (RequestedType == "Plastic"){
						Available = RequestedWeight <= Available_Plastic
					}
				else 
					{	
						println("WASTE_SERVICE | WRONG TYPE")
						Available = false
					}
			#]
			
			if [# (Available)#] {
			//replyTo waste with  loadAccept : info(ok)
			} else {
				updateResource[#"weights(Glass=$Available_Glass Plastic=$Available_Plastic)"#]
			replyTo waste with  loadRejected : info(rip)
			}			
		}
	}
	Goto  issue_trolley if [#Available# ] else accepting
	
	State issue_trolley {
		
		println("WASTE_SERVICE | ISSUE TROLLEY")
		request transporttrolley -m goal : destination($RequestedType)
		
	}
	Transition t1 whenReply workdone -> lost_pickup 
				  whenEvent pickup -> updateWeights	
	
	State lost_pickup{
		
		[#
			
			if (RequestedType == "Glass"){
						Available_Glass -= RequestedWeight 
					}
			else if (RequestedType == "Plastic"){
						Available_Plastic -= RequestedWeight 
					}
			else 
					{	
						println("WASTE_SERVICE | ERROR LOST PICKUP")
					}
	
		#]
			updateResource[#"weights(Glass=$Available_Glass Plastic=$Available_Plastic)"#]
		replyTo waste with loadAccept : 	info(ok)
		
	}
	Goto accepting
	
	
	State updateWeights{
			[#
			
			if (RequestedType == "Glass"){
						Available_Glass -= RequestedWeight 
					}
			else if (RequestedType == "Plastic"){
						Available_Plastic -= RequestedWeight 
					}
			else 
					{
						println("WASTE_SERVICE | ERROR UPDATE WEIGHTS")

					}
	
			#]
			
			updateResource[#"weights(Glass=$Available_Glass Plastic=$Available_Plastic)"#]
		replyTo waste with loadAccept : info(ok)
	}
	Goto acceptBusy
	
	State acceptBusy{
		
		println("WASTE_SERVICE | ACCEPTING(BUSY)")
	}
	Transition t2 whenReply workdone -> accepting
				  whenRequest waste -> checkWhenBusy
				  whenMsg reset -> reset_weightsBusy
	
	
	State reset_weightsBusy {
		
		println("WASTE_SERVICE | (BUSY) SHOULD ONLY BE IN TESTING, RESET WEIGHTS")
	
	
		[#
		
		Available_Glass = Init_Glass
		Available_Plastic = Init_Plastic
		
			
		#]
			updateResource[#"weights(Glass=$Available_Glass Plastic=$Available_Plastic)"#]
	}
	Goto acceptBusy
	
	
	
	
	State checkWhenBusy{
		printCurrentMessage
		println("WASTE_SERVICE | CHECK AVAILABILITY")	
		onMsg ( waste : details(TYPE,TRUCKLOAD) ) {
			[#
				RequestedType = payloadArg(0)
				RequestedWeight = payloadArg(1).toInt()

					if (RequestedType == "Glass"){
						Available = RequestedWeight <= Available_Glass
					}
					else if (RequestedType == "Plastic"){
						Available = RequestedWeight <= Available_Plastic
					}
				else 
					{	
						println("WASTE_SERVICE | WRONG TYPE")
						Available = false
					}
			#]
			
			if [# (Available)#] {
			//replyTo waste with  loadAccept : info(ok)
			} else {
				updateResource[#"weights(Glass=$Available_Glass Plastic=$Available_Plastic)"#]
			replyTo waste with  loadRejected : info(rip)
			}			
		}
	}
	Goto addRequestToQueue if [# Available#] else acceptBusy
	
	State addRequestToQueue{
		
		println("WASTE_SERVICE | ISSUE TROLLEY TO QUEUE")
		request transporttrolley -m goal : destination($RequestedType)
		
	}
	Goto acceptBusy
}